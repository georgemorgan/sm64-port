# Macros for disassembled sequence files. This file was automatically generated by seq_decoder.py.
# To regenerate it, run: ./tools/seq_decoder.py --emit-asm-macros >seq_macros.inc

# seq commands

.macro seq_testchdisabled
    .byte 0x0 + $0
.endm

.macro seq_subvariation
    .byte 0x50 + $0
.endm

.macro seq_setvariation
    .byte 0x70 + $0
.endm

.macro seq_getvariation
    .byte 0x80 + $0
.endm

.macro seq_startchannel
    .byte 0x90 + $0
    .byte ($1 - sequence_start) >> 8, ($1 - sequence_start) & 0xff
.endm

.macro seq_subtract
    .byte 0xc8
    .byte $0
.endm

.macro seq_bitand
    .byte 0xc9
    .byte $0
.endm

.macro seq_setval
    .byte 0xcc
    .byte $0
.endm

.macro seq_setnoteallocationpolicy
    .byte 0xd0
    .byte $0
.endm

.macro seq_setshortnotedurationtable
    .byte 0xd1
    .byte ($0 - sequence_start) >> 8, ($0 - sequence_start) & 0xff
.endm

.macro seq_setshortnotevelocitytable
    .byte 0xd2
    .byte ($0 - sequence_start) >> 8, ($0 - sequence_start) & 0xff
.endm

.macro seq_setmutebhv
    .byte 0xd3
    .byte $0
.endm

.macro seq_mute
    .byte 0xd4
.endm

.macro seq_setmutescale
    .byte 0xd5
    .byte $0
.endm

.macro seq_disablechannels
    .byte 0xd6
    .byte $0 >> 8, $0 & 0xff
.endm

.macro seq_initchannels
    .byte 0xd7
    .byte $0 >> 8, $0 & 0xff
.endm

.macro seq_changevol
    .byte 0xda
    .byte $0
.endm

.macro seq_setvol
    .byte 0xdb
    .byte $0
.endm

.macro seq_addtempo
    .byte 0xdc
    .byte $0
.endm

.macro seq_settempo
    .byte 0xdd
    .byte $0
.endm

.macro seq_transposerel
    .byte 0xde
    .byte $0
.endm

.macro seq_transpose
    .byte 0xdf
    .byte $0
.endm

.macro seq_bgez
    .byte 0xf5
    .byte ($0 - sequence_start) >> 8, ($0 - sequence_start) & 0xff
.endm

.macro seq_loopend
    .byte 0xf7
.endm

.macro seq_loop
    .byte 0xf8
    .byte $0
.endm

.macro seq_bltz
    .byte 0xf9
    .byte ($0 - sequence_start) >> 8, ($0 - sequence_start) & 0xff
.endm

.macro seq_beqz
    .byte 0xfa
    .byte ($0 - sequence_start) >> 8, ($0 - sequence_start) & 0xff
.endm

.macro seq_jump
    .byte 0xfb
    .byte ($0 - sequence_start) >> 8, ($0 - sequence_start) & 0xff
.endm

.macro seq_call
    .byte 0xfc
    .byte ($0 - sequence_start) >> 8, ($0 - sequence_start) & 0xff
.endm

.macro seq_delay
    .byte 0xfd
    var $0
.endm

.macro seq_delay1
    .byte 0xfe
.endm

.macro seq_end
    .byte 0xff
.endm

.ifdef VERSION_EU

.macro seq_unreservenotes
    .byte 0xf0
.endm

.macro seq_reservenotes
    .byte 0xf1
    .byte $0
.endm

.else

.macro seq_unreservenotes
    .byte 0xf1
.endm

.macro seq_reservenotes
    .byte 0xf2
    .byte $0
.endm

.endif

# chan commands

.macro chan_testlayerfinished
    .byte 0x0 + $0
.endm

.macro chan_startchannel
    .byte 0x10 + $0
    .byte ($1 - sequence_start) >> 8, ($1 - sequence_start) & 0xff
.endm

.macro chan_disablechannel
    .byte 0x20 + $0
.endm

.macro chan_iowriteval2
    .byte 0x30 + $0
    .byte $1
.endm

.macro chan_ioreadval2
    .byte 0x40 + $0
    .byte $1
.endm

.macro chan_ioreadvalsub
    .byte 0x50 + $0
.endm

.macro chan_iowriteval
    .byte 0x70 + $0
.endm

.macro chan_ioreadval
    .byte 0x80 + $0
.endm

.macro chan_setlayer
    .byte 0x90 + $0
    .byte ($1 - sequence_start) >> 8, ($1 - sequence_start) & 0xff
.endm

.macro chan_freelayer
    .byte 0xa0 + $0
.endm

.macro chan_dynsetlayer
    .byte 0xb0 + $0
.endm

.macro chan_setinstr
    .byte 0xc1
    .byte $0
.endm

.macro chan_setdyntable
    .byte 0xc2
    .byte ($0 - sequence_start) >> 8, ($0 - sequence_start) & 0xff
.endm

.macro chan_largenotesoff
    .byte 0xc3
.endm

.macro chan_largenoteson
    .byte 0xc4
.endm

.macro chan_dynsetdyntable
    .byte 0xc5
.endm

.macro chan_setbank
    .byte 0xc6
    .byte $0
.endm

.macro chan_subtract
    .byte 0xc8
    .byte $0
.endm

.macro chan_bitand
    .byte 0xc9
    .byte $0
.endm

.macro chan_setmutebhv
    .byte 0xca
    .byte $0
.endm

.macro chan_readseq
    .byte 0xcb
    .byte ($0 - sequence_start) >> 8, ($0 - sequence_start) & 0xff
.endm

.macro chan_setval
    .byte 0xcc
    .byte $0
.endm

.macro chan_stereoheadseteffects
    .byte 0xd0
    .byte $0
.endm

.macro chan_setnoteallocationpolicy
    .byte 0xd1
    .byte $0
.endm

.macro chan_setsustain
    .byte 0xd2
    .byte $0
.endm

.macro chan_pitchbend
    .byte 0xd3
    .byte $0
.endm

.macro chan_setreverb
    .byte 0xd4
    .byte $0
.endm

.macro chan_setupdatesperframe_unimplemented
    .byte 0xd6
    .byte $0
.endm

.macro chan_setvibratorate
    .byte 0xd7
    .byte $0
.endm

.macro chan_setvibratoextent
    .byte 0xd8
    .byte $0
.endm

.macro chan_setdecayrelease
    .byte 0xd9
    .byte $0
.endm

.macro chan_setenvelope
    .byte 0xda
    .byte ($0 - sequence_start) >> 8, ($0 - sequence_start) & 0xff
.endm

.macro chan_transpose
    .byte 0xdb
    .byte $0
.endm

.macro chan_setpanmix
    .byte 0xdc
    .byte $0
.endm

.macro chan_setpan
    .byte 0xdd
    .byte $0
.endm

.macro chan_freqscale
    .byte 0xde
    .byte $0 >> 8, $0 & 0xff
.endm

.macro chan_setvol
    .byte 0xdf
    .byte $0
.endm

.macro chan_setvolscale
    .byte 0xe0
    .byte $0
.endm

.macro chan_setvibratoratelinear
    .byte 0xe1
    .byte $0
    .byte $1
    .byte $2
.endm

.macro chan_setvibratoextentlinear
    .byte 0xe2
    .byte $0
    .byte $1
    .byte $2
.endm

.macro chan_setvibratodelay
    .byte 0xe3
    .byte $0
.endm

.macro chan_dyncall
    .byte 0xe4
.endm

.macro chan_hang
    .byte 0xf3
.endm

.macro chan_bgez
    .byte 0xf5
    .byte ($0 - sequence_start) >> 8, ($0 - sequence_start) & 0xff
.endm

.macro chan_break
    .byte 0xf6
.endm

.macro chan_loopend
    .byte 0xf7
.endm

.macro chan_loop
    .byte 0xf8
    .byte $0
.endm

.macro chan_bltz
    .byte 0xf9
    .byte ($0 - sequence_start) >> 8, ($0 - sequence_start) & 0xff
.endm

.macro chan_beqz
    .byte 0xfa
    .byte ($0 - sequence_start) >> 8, ($0 - sequence_start) & 0xff
.endm

.macro chan_jump
    .byte 0xfb
    .byte ($0 - sequence_start) >> 8, ($0 - sequence_start) & 0xff
.endm

.macro chan_call
    .byte 0xfc
    .byte ($0 - sequence_start) >> 8, ($0 - sequence_start) & 0xff
.endm

.macro chan_delay
    .byte 0xfd
    var $0
.endm

.macro chan_delay1
    .byte 0xfe
.endm

.macro chan_end
    .byte 0xff
.endm

.macro chan_writeseq val, pos, offset
    .byte 0xc7, $val
    .byte ($pos - sequence_start + $offset) >> 8, ($pos - sequence_start + $offset) & 0xff
.endm

.macro chan_writeseq_nextinstr val, offset
    .byte 0xc7, $val
    .byte (writeseq$@ - sequence_start + $offset) >> 8, (writeseq$@ - sequence_start + $offset) & 0xff
    writeseq$@:
.endm

.macro layer_portamento
    .byte 0xc7, $0, $1
    .if (($0 & 0x80) == 0)
        var $2
    .else
        .byte $2
    .endif
.endm

.macro chan_delay_long
    .byte 0xfd
    var_long $0
.endm

.ifdef VERSION_EU

.macro chan_setnotepriority
    .byte 0xe9
    .byte $0
.endm

.macro chan_unreservenotes
    .byte 0xf0
.endm

.macro chan_reservenotes
    .byte 0xf1
    .byte $0
.endm

.else

.macro chan_setnotepriority
    .byte 0x60 + $0
.endm

.macro chan_unreservenotes
    .byte 0xf1
.endm

.macro chan_reservenotes
    .byte 0xf2
    .byte $0
.endm

.endif

# layer commands

.macro layer_note0
    .byte 0x0 + $0
    var $1
    .byte $2
    .byte $3
.endm

.macro layer_note1
    .byte 0x40 + $0
    var $1
    .byte $2
.endm

.macro layer_note2
    .byte 0x80 + $0
    .byte $1
    .byte $2
.endm

.macro layer_delay
    .byte 0xc0
    var $0
.endm

.macro layer_setshortnotevelocity
    .byte 0xc1
    .byte $0
.endm

.macro layer_transpose
    .byte 0xc2
    .byte $0
.endm

.macro layer_setshortnotedefaultplaypercentage
    .byte 0xc3
    var $0
.endm

.macro layer_somethingon
    .byte 0xc4
.endm

.macro layer_somethingoff
    .byte 0xc5
.endm

.macro layer_setinstr
    .byte 0xc6
    .byte $0
.endm

.macro layer_disableportamento
    .byte 0xc8
.endm

.macro layer_setshortnoteduration
    .byte 0xc9
    .byte $0
.endm

.macro layer_setpan
    .byte 0xca
    .byte $0
.endm

.macro layer_setshortnotevelocityfromtable
    .byte 0xd0 + $0
.endm

.macro layer_setshortnotedurationfromtable
    .byte 0xe0 + $0
.endm

.macro layer_loopend
    .byte 0xf7
.endm

.macro layer_loop
    .byte 0xf8
    .byte $0
.endm

.macro layer_jump
    .byte 0xfb
    .byte ($0 - sequence_start) >> 8, ($0 - sequence_start) & 0xff
.endm

.macro layer_call
    .byte 0xfc
    .byte ($0 - sequence_start) >> 8, ($0 - sequence_start) & 0xff
.endm

.macro layer_end
    .byte 0xff
.endm

.macro layer_delay_long
    .byte 0xc0
    var_long $0
.endm

.macro layer_note1_long
    .byte 0x40 + $0
    var_long $1
    .byte $2
.endm

# envelope commands

.macro envelope_disable a
    .byte 0x0, 0x0
    .byte $a >> 8, $a & 0xff
.endm

.macro envelope_hang a
    .byte 0xff, 0xff
    .byte $a >> 8, $a & 0xff
.endm

.macro envelope_goto a
    .byte 0xff, 0xfe
    .byte $a >> 8, $a & 0xff
.endm

.macro envelope_restart a
    .byte 0xff, 0xfd
    .byte $a >> 8, $a & 0xff
.endm

.macro envelope_line a, b
    .byte $a >> 8, $a & 0xff
    .byte $b >> 8, $b & 0xff
.endm

# other commands

.macro var_long
     .byte (0x80 | ($0 & 0x7f00) >> 8), ($0 & 0xff)
.endm

.macro var
    .if ($0 >= 0x80)
        var_long $0
    .else
        .byte $0
    .endif
.endm

.macro sound_ref
    .byte ($0 - sequence_start) >> 8, ($0 - sequence_start) & 0xff
.endm
