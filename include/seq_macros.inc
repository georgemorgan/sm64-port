# Macros for disassembled sequence files. This file was automatically generated by seq_decoder.py.
# To regenerate it, run: ./tools/seq_decoder.py --emit-asm-macros >seq_macros.inc

# seq commands

.macro seq_testchdisabled
    .byte 0x0 + $0
.endm

.macro seq_subvariation
    .byte 0x50 + $0
.endm

.macro seq_setvariation
    .byte 0x70 + $0
.endm

.macro seq_getvariation
    .byte 0x80 + $0
.endm

.macro seq_startchannel
    .byte 0x90 + $0
    byte_a = (($1 - sequence_start) >> 8)
    byte_b = (($1 - sequence_start) & 0xff)
    .byte byte_3921_a, byte_3921_b
.endm

.macro seq_subtract
    .byte 0xc8
    .byte $0
.endm

.macro seq_bitand
    .byte 0xc9
    .byte $0
.endm

.macro seq_setval
    .byte 0xcc
    .byte $0
.endm

.macro seq_setnoteallocationpolicy
    .byte 0xd0
    .byte $0
.endm

.macro seq_setshortnotedurationtable
    .byte 0xd1
    byte_a = (($0 - sequence_start) >> 8)
    byte_b = (($0 - sequence_start) & 0xff)
    .byte byte_3542_a, byte_3542_b
.endm

.macro seq_setshortnotevelocitytable
    .byte 0xd2
    byte_a = (($0 - sequence_start) >> 8)
    byte_b = (($0 - sequence_start) & 0xff)
    .byte byte_4313_a, byte_4313_b
.endm

.macro seq_setmutebhv
    .byte 0xd3
    .byte $0
.endm

.macro seq_mute
    .byte 0xd4
.endm

.macro seq_setmutescale
    .byte 0xd5
    .byte $0
.endm

.macro seq_disablechannels
    .byte 0xd6
    byte_a = ($0 >> 8)
    byte_b = ($0 & 0xff)
    .byte byte_1557_a, byte_1557_b
.endm

.macro seq_initchannels
    .byte 0xd7
    byte_a = ($0 >> 8)
    byte_b = ($0 & 0xff)
    .byte byte_2884_a, byte_2884_b
.endm

.macro seq_changevol
    .byte 0xda
    .byte $0
.endm

.macro seq_setvol
    .byte 0xdb
    .byte $0
.endm

.macro seq_addtempo
    .byte 0xdc
    .byte $0
.endm

.macro seq_settempo
    .byte 0xdd
    .byte $0
.endm

.macro seq_transposerel
    .byte 0xde
    .byte $0
.endm

.macro seq_transpose
    .byte 0xdf
    .byte $0
.endm

.macro seq_bgez
    .byte 0xf5
    byte_a = (($0 - sequence_start) >> 8)
    byte_b = (($0 - sequence_start) & 0xff)
    .byte byte_7403_a, byte_7403_b
.endm

.macro seq_loopend
    .byte 0xf7
.endm

.macro seq_loop
    .byte 0xf8
    .byte $0
.endm

.macro seq_bltz
    .byte 0xf9
    byte_a = (($0 - sequence_start) >> 8)
    byte_b = (($0 - sequence_start) & 0xff)
    .byte byte_8031_a, byte_8031_b
.endm

.macro seq_beqz
    .byte 0xfa
    byte_a = (($0 - sequence_start) >> 8)
    byte_b = (($0 - sequence_start) & 0xff)
    .byte byte_3075_a, byte_3075_b
.endm

.macro seq_jump
    .byte 0xfb
    byte_a = (($0 - sequence_start) >> 8)
    byte_b = (($0 - sequence_start) & 0xff)
    .byte byte_9347_a, byte_9347_b
.endm

.macro seq_call
    .byte 0xfc
    byte_a = (($0 - sequence_start) >> 8)
    byte_b = (($0 - sequence_start) & 0xff)
    .byte byte_9510_a, byte_9510_b
.endm

.macro seq_delay
    .byte 0xfd
    var $0
.endm

.macro seq_delay1
    .byte 0xfe
.endm

.macro seq_end
    .byte 0xff
.endm

.ifdef VERSION_EU

.macro seq_unreservenotes
    .byte 0xf0
.endm

.macro seq_reservenotes
    .byte 0xf1
    .byte $0
.endm

.else

.macro seq_unreservenotes
    .byte 0xf1
.endm

.macro seq_reservenotes
    .byte 0xf2
    .byte $0
.endm

.endif

# chan commands

.macro chan_testlayerfinished
    .byte 0x0 + $0
.endm

.macro chan_startchannel
    .byte 0x10 + $0
    byte_a = (($1 - sequence_start) >> 8)
    byte_b = (($1 - sequence_start) & 0xff)
    .byte byte_4868_a, byte_4868_b
.endm

.macro chan_disablechannel
    .byte 0x20 + $0
.endm

.macro chan_iowriteval2
    .byte 0x30 + $0
    .byte $1
.endm

.macro chan_ioreadval2
    .byte 0x40 + $0
    .byte $1
.endm

.macro chan_ioreadvalsub
    .byte 0x50 + $0
.endm

.macro chan_iowriteval
    .byte 0x70 + $0
.endm

.macro chan_ioreadval
    .byte 0x80 + $0
.endm

.macro chan_setlayer
    .byte 0x90 + $0
    byte_a = (($1 - sequence_start) >> 8)
    byte_b = (($1 - sequence_start) & 0xff)
    .byte byte_8143_a, byte_8143_b
.endm

.macro chan_freelayer
    .byte 0xa0 + $0
.endm

.macro chan_dynsetlayer
    .byte 0xb0 + $0
.endm

.macro chan_setinstr
    .byte 0xc1
    .byte $0
.endm

.macro chan_setdyntable
    .byte 0xc2
    byte_a = (($0 - sequence_start) >> 8)
    byte_b = (($0 - sequence_start) & 0xff)
    .byte byte_2188_a, byte_2188_b
.endm

.macro chan_largenotesoff
    .byte 0xc3
.endm

.macro chan_largenoteson
    .byte 0xc4
.endm

.macro chan_dynsetdyntable
    .byte 0xc5
.endm

.macro chan_setbank
    .byte 0xc6
    .byte $0
.endm

.macro chan_subtract
    .byte 0xc8
    .byte $0
.endm

.macro chan_bitand
    .byte 0xc9
    .byte $0
.endm

.macro chan_setmutebhv
    .byte 0xca
    .byte $0
.endm

.macro chan_readseq
    .byte 0xcb
    byte_a = (($0 - sequence_start) >> 8)
    byte_b = (($0 - sequence_start) & 0xff)
    .byte byte_3742_a, byte_3742_b
.endm

.macro chan_setval
    .byte 0xcc
    .byte $0
.endm

.macro chan_stereoheadseteffects
    .byte 0xd0
    .byte $0
.endm

.macro chan_setnoteallocationpolicy
    .byte 0xd1
    .byte $0
.endm

.macro chan_setsustain
    .byte 0xd2
    .byte $0
.endm

.macro chan_pitchbend
    .byte 0xd3
    .byte $0
.endm

.macro chan_setreverb
    .byte 0xd4
    .byte $0
.endm

.macro chan_setupdatesperframe_unimplemented
    .byte 0xd6
    .byte $0
.endm

.macro chan_setvibratorate
    .byte 0xd7
    .byte $0
.endm

.macro chan_setvibratoextent
    .byte 0xd8
    .byte $0
.endm

.macro chan_setdecayrelease
    .byte 0xd9
    .byte $0
.endm

.macro chan_setenvelope
    .byte 0xda
    byte_a = (($0 - sequence_start) >> 8)
    byte_b = (($0 - sequence_start) & 0xff)
    .byte byte_8485_a, byte_8485_b
.endm

.macro chan_transpose
    .byte 0xdb
    .byte $0
.endm

.macro chan_setpanmix
    .byte 0xdc
    .byte $0
.endm

.macro chan_setpan
    .byte 0xdd
    .byte $0
.endm

.macro chan_freqscale
    .byte 0xde
    byte_a = ($0 >> 8)
    byte_b = ($0 & 0xff)
    .byte byte_8883_a, byte_8883_b
.endm

.macro chan_setvol
    .byte 0xdf
    .byte $0
.endm

.macro chan_setvolscale
    .byte 0xe0
    .byte $0
.endm

.macro chan_setvibratoratelinear
    .byte 0xe1
    .byte $0
    .byte $1
    .byte $2
.endm

.macro chan_setvibratoextentlinear
    .byte 0xe2
    .byte $0
    .byte $1
    .byte $2
.endm

.macro chan_setvibratodelay
    .byte 0xe3
    .byte $0
.endm

.macro chan_dyncall
    .byte 0xe4
.endm

.macro chan_hang
    .byte 0xf3
.endm

.macro chan_bgez
    .byte 0xf5
    byte_a = (($0 - sequence_start) >> 8)
    byte_b = (($0 - sequence_start) & 0xff)
    .byte byte_3444_a, byte_3444_b
.endm

.macro chan_break
    .byte 0xf6
.endm

.macro chan_loopend
    .byte 0xf7
.endm

.macro chan_loop
    .byte 0xf8
    .byte $0
.endm

.macro chan_bltz
    .byte 0xf9
    byte_a = (($0 - sequence_start) >> 8)
    byte_b = (($0 - sequence_start) & 0xff)
    .byte byte_1589_a, byte_1589_b
.endm

.macro chan_beqz
    .byte 0xfa
    byte_a = (($0 - sequence_start) >> 8)
    byte_b = (($0 - sequence_start) & 0xff)
    .byte byte_1207_a, byte_1207_b
.endm

.macro chan_jump
    .byte 0xfb
    byte_a = (($0 - sequence_start) >> 8)
    byte_b = (($0 - sequence_start) & 0xff)
    .byte byte_7704_a, byte_7704_b
.endm

.macro chan_call
    .byte 0xfc
    byte_a = (($0 - sequence_start) >> 8)
    byte_b = (($0 - sequence_start) & 0xff)
    .byte byte_5913_a, byte_5913_b
.endm

.macro chan_delay
    .byte 0xfd
    var $0
.endm

.macro chan_delay1
    .byte 0xfe
.endm

.macro chan_end
    .byte 0xff
.endm

.macro chan_writeseq
    .byte 0xc7, $0
    byte_a = (($1 - sequence_start + $2) >> 8)
    byte_b = (($1 - sequence_start + $2) & 0xff)
    .byte byte_1508_a, byte_1508_b
.endm

.macro chan_writeseq_nextinstr
    .byte 0xc7, $1
    byte_a = ((writeseq_$0 - sequence_start + $2) >> 8)
    byte_b = ((writeseq_$0 - sequence_start + $2) & 0xff)
    .byte byte_7107_a, byte_7107_b
    writeseq_$0:
.endm

.macro layer_portamento
    .byte 0xc7, $0, $1
    .if (($0 & 0x80) == 0)
        var $2
    .else
        .byte $2
    .endif
.endm

.macro chan_delay_long
    .byte 0xfd
    var_long $0
.endm

.ifdef VERSION_EU

.macro chan_setnotepriority
    .byte 0xe9
    .byte $0
.endm

.macro chan_unreservenotes
    .byte 0xf0
.endm

.macro chan_reservenotes
    .byte 0xf1
    .byte $0
.endm

.else

.macro chan_setnotepriority
    .byte 0x60 + $0
.endm

.macro chan_unreservenotes
    .byte 0xf1
.endm

.macro chan_reservenotes
    .byte 0xf2
    .byte $0
.endm

.endif

# layer commands

.macro layer_note0
    .byte 0x0 + $0
    var $1
    .byte $2
    .byte $3
.endm

.macro layer_note1
    .byte 0x40 + $0
    var $1
    .byte $2
.endm

.macro layer_note2
    .byte 0x80 + $0
    .byte $1
    .byte $2
.endm

.macro layer_delay
    .byte 0xc0
    var $0
.endm

.macro layer_setshortnotevelocity
    .byte 0xc1
    .byte $0
.endm

.macro layer_transpose
    .byte 0xc2
    .byte $0
.endm

.macro layer_setshortnotedefaultplaypercentage
    .byte 0xc3
    var $0
.endm

.macro layer_somethingon
    .byte 0xc4
.endm

.macro layer_somethingoff
    .byte 0xc5
.endm

.macro layer_setinstr
    .byte 0xc6
    .byte $0
.endm

.macro layer_disableportamento
    .byte 0xc8
.endm

.macro layer_setshortnoteduration
    .byte 0xc9
    .byte $0
.endm

.macro layer_setpan
    .byte 0xca
    .byte $0
.endm

.macro layer_setshortnotevelocityfromtable
    .byte 0xd0 + $0
.endm

.macro layer_setshortnotedurationfromtable
    .byte 0xe0 + $0
.endm

.macro layer_loopend
    .byte 0xf7
.endm

.macro layer_loop
    .byte 0xf8
    .byte $0
.endm

.macro layer_jump
    .byte 0xfb
    byte_a = (($0 - sequence_start) >> 8)
    byte_b = (($0 - sequence_start) & 0xff)
    .byte byte_524_a, byte_524_b
.endm

.macro layer_call
    .byte 0xfc
    byte_a = (($0 - sequence_start) >> 8)
    byte_b = (($0 - sequence_start) & 0xff)
    .byte byte_4752_a, byte_4752_b
.endm

.macro layer_end
    .byte 0xff
.endm

.macro layer_delay_long
    .byte 0xc0
    var_long $0
.endm

.macro layer_note1_long
    .byte 0x40 + $0
    var_long $1
    .byte $2
.endm

# envelope commands

.macro envelope_disable
    .byte 0x0, 0x0
    byte_a = ($0 >> 8)
    byte_b = ($0 & 0xff)
    .byte byte_457_a, byte_457_b
.endm

.macro envelope_hang
    .byte 0xff, 0xff
    byte_a = ($0 >> 8)
    byte_b = ($0 & 0xff)
    .byte byte_6920_a, byte_6920_b
.endm

.macro envelope_goto
    .byte 0xff, 0xfe
    byte_a = ($0 >> 8)
    byte_b = ($0 & 0xff)
    .byte byte_4432_a, byte_4432_b
.endm

.macro envelope_restart
    .byte 0xff, 0xfd
    byte_a = ($0 >> 8)
    byte_b = ($0 & 0xff)
    .byte byte_7411_a, byte_7411_b
.endm

.macro envelope_line
    byte_a = ($0 >> 8)
    byte_b = ($0 & 0xff)
    .byte byte_8635_a, byte_8635_b
    byte_a = ($1 >> 8)
    byte_b = ($1 & 0xff)
    .byte byte_9743_a, byte_9743_b
.endm

# other commands

.macro var_long
     .byte (0x80 | ($0 & 0x7f00) >> 8), ($0 & 0xff)
.endm

.macro var
    .if ($0 >= 0x80)
        var_long $0
    .else
        .byte $0
    .endif
.endm

.macro sound_ref
    byte_a = (($0 - sequence_start) >> 8)
    byte_b = (($0 - sequence_start) & 0xff)
    .byte byte_318_a, byte_318_b
.endm
